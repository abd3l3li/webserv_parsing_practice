
Q&A:

 - you have to understand all the filled field role
 - why using 300 > code

 - explain me this syntax get().x
    * it calls get() then access the data.

 - how it this struct linked to tokens struct
    * tokens gathered by tokenizer got passed to parser constructor


 - what is diff between peek and get
   * peek for taking a sight 
   * get for sight and moving o

 --- explain me more about of the location /upload for ex, why need this then again in the block we get anoter one

 -- how the three classes connected to each other and how is the relation worked

 - Token(TokenType t, const std::string& txt), t have no reference?
    *âœ… Cheap to copy (usually 4 bytes)
    *So there's no need to pass them by reference.
    *In fact, passing by reference might be slower because:
    *It involves dereferencing a memory address

The reference still has to be stored (usually 8 bytes on 64-bit machines)

 -- max size is for what in the config

 --- is it ok to let a field empty like in methods

 - this is my final code i want you to tell me all the considered and required case i have to 
    handle like nginx in the subject and then work with me one by one to edit them in my code to 
    move on to the next part in my section as person B

 ---------------------------------------------------------------------------------------------------

ðŸ“˜ Functions in Parser.cpp :

ðŸ§  Summary Table :

 | Function / Loop           | What it does                                                 |
| ------------------------- | ------------------------------------------------------------ |
| Parser::Parser(...)       | Saves the list of tokens and resets the cursor (\_index)     |
| peek()                    | Look at the current token (no advance)                       |
| get()                     | Get the current token and move to the next                   |
| while (not END\_OF\_FILE) | Loop through all server blocks                               |
| while (inside server)     | Parse server directives and location blocks                  |
| while (inside location)   | Parse location settings like root, index, autoindex, methods |

notes:

    split the parser code

-------------------- my understanding of parser funcs --------------------------

- the first loop works for checking for more than one server creatin new ServerConfig each time .
- the second loop works for checking single element each time in a server and creating new key to each time 
    to check for keywords and storing the value in the serverConfig val .
- the third loop works for doing the same as the server one but for the location block and then
    it store the matched values in the location vector of ServerConfig .
- the fourth one works for the methods that will be stored in one of Locations vector.

-----------------------------------

Token vector structure:

    Imagine this tokenized input:

    server {
    listen 127.0.0.1:8080;
    }

    becomes:

    std::vector<Token> tokens = {
    Token(KEYWORD, "server"),
    Token(BRACE_OPEN, "{"),
    Token(KEYWORD, "listen"),
    Token(VALUE, "127.0.0.1:8080"),
    Token(SEMICOLON, ";"),
    Token(BRACE_CLOSE, "}"),
    Token(END_OF_FILE, "")
    };

-----------------------------------

Config Parser::parse()
{
        while (peek().type != BRACE_CLOSE && peek().type != END_OF_FILE) //why eof
        {} 
}
